---
title: "Bioconductor"
author: "Eda Emanet"
date: "10 01 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Bioconductor version
In the video, you learned about the Bioconductor project. One advantage of this fantastic resource is its continuous improvements, reflected in scheduled releases. Hence, checking the current version is important for the reproducibility of your analysis.

Important note: For this course, you will be using the BiocInstaller package to install and check package versions, as we will be using Bioconductor version 3.6. For details on the latest Bioconductor installation instructions see Bioconductor install page.

The package BiocInstaller has been installed using source("https://bioconductor.org/biocLite.R"). Remember, you can check the Bioconductor version using the function biocVersion() from the BiocInstaller package.
Your task is to check the R version and the Bioconductor version, currently being used:

Check the R version using version (without parenthesis).
Check the version of Bioconductor using the syntax package::function().

```{r}
# Load the BiocInstaller package
library(BiocInstaller)

# Check R version
version

# Explicit syntax to check the Bioconductor version
BiocInstaller::biocVersion()
```
BiocLite to install packages
As example to install packages we will use the BSgenome package. This is a data package which contains representations of several genomes. When you install a new package it usually calls installations for its dependencies that takes some time, hence we have already installed BSgenome for you to use on this exercise.

Note: Using Bioconductor version 3.7 or earlier, packages can be installed using the following code:

# Using Bioconductor version 3.6
source("https://bioconductor.org/biocLite.R")
biocLite("BSgenome")

# Load the package
library(BSgenome)
For versions 3.8 or higher, you will use the BiocManager instead.

For this exercise, you should not use source() or biocLite() to install BSgenome. This has already been done for you.

You can load the package using library(packageName) and check the package's version using the function packageVersion("packageName").

Instructions
100 XP
Instructions
100 XP
Use library() to load the package BSgenome. Note that BSgenome has already been installed for you.
Read the output messages and view the required packages.
Check the installed version of BSgenome.
```{r}
# Load the BSgenome package
library(BSgenome)

# Check the version of the BSgenome package
packageVersion("BSgenome")

```
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("BSgenome")
```

Biostring indirmek i√ßin
----------------------------------------------------------------------------------------------------------------
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Biostrings")

--------------------------------------------------------------------------------------------------------------



Interaction with classes
Let's say we have an object called a_genome from class BSgenome. With a_genome, you can ask questions like these:

# What is a_genome's main class?
class(a_genome)  # "BSgenome"

# What is a_genome's other classes?
is(a_genome)  # "BSgenome", "GenomeDescription"

# Is a_genome an S4 representation?
isS4(a_genome)  # TRUE
If you want to find out more about the a_genome object, you can use the accessor show(a_genome) or use other specific accessors from the list of .S4methods(class = "BSgenome").

Instructions 2/2
50 XP
2
Investigate a_genome using other accessors such as organism(), provider(), and seqinfo().
```{r}
# Investigate the a_genome using show()
show(a_genome)

# Investigate some other accesors
organism(a_genome)
provider(a_genome)
seqinfo(a_genome)
```
Keep up the good work! You can now check other objects and investigate if they are S4 objects, their classes, and their accessors. Remember, you can use .S4methods() or showMethods() to check the accessors list of a class or a function.

Discovering the Yeast genome
Let's continue to explore the yeast genome using the package BSgenome.Scerevisiae.UCSC.sacCer3 which is already installed for you.

As with other data in R, we can use head() and tail() to explore the yeastGenome object. We can also subset the genome by chromosome by using $ as follows: object_name$chromosome_name. If you need the names of the chromosomes use the names() function.

Another nifty function is nchar(), used to count the number of characters in a sequence.
```{r}
# Load the yeast genome
library(BSgenome.Scerevisiae.UCSC.sacCer3)

# Assign data to the yeastGenome object
yeastGenome <- BSgenome.Scerevisiae.UCSC.sacCer3

# Get the head of seqnames and tail of seqlengths for yeastGenome
head(seqnames(yeastGenome))
tail(seqlengths(yeastGenome))

# Print chromosome M, alias chrM
yeastGenome$chrM


# Count characters of the chrM sequence
nchar(yeastGenome$chrM)
```
Partitioning the Yeast genome
Genomes are often big, but interest usually lies in specific regions of them. Therefore, we need to subset a genome by extracting parts of it. To pick a sequence interval use getSeq() and specify the name of the chromosome, and the start and end of the sequence interval:

getSeq(yeastGenome, names = "chrI", start = 100, end = 150)
Notice that names is optional; if not specified, it will return all chromosomes. The parameters start and end are also optional and, if not specified, will take the default values 1 and the length of the sequence respectively.

Instructions
100 XP
Use getSeq() to get the first 30 bases of each chromosome in the yeastGenome object.

```{r}
# Load the yeast genome
library(BSgenome.Scerevisiae.UCSC.sacCer3)

# Assign data to the yeastGenome object
yeastGenome <- BSgenome.Scerevisiae.UCSC.sacCer3

# Get the first 30 bases of each chromosome
getSeq(yeastGenome, start=1, end =30)
```
Available Genomes
As a recap, the BSgenome package makes available various public genomes. If you want to explore the available genomes from this package, you can use:

available.genomes()
The list of names will appear in the following format: BSgenome.speciesName.provider.version.

After running this function, can you tell which is the major provider of available genomes?

Exploring the Zika virus sequence
It's your turn to explore the Zika virus genome, which has been loaded in your workspace as zikaVirus. The genome was downloaded from NCBI and you can apply Biostrings functions to learn more about it.

Start by checking the alphabet of the sequence.

alphabet() # Shows the letters included in the sequence
alphabetFrequency() # Shows the counts per letter
Remember from the video that each alphabet corresponds to a specific biostring container, and each alphabet usually has extra code letters and symbols.
```{r}
# Load packages
library(Biostrings)

# Check the alphabet of the zikaVirus
alphabet(zikaVirus)

# Check the alphabetFrequency of the zikaVirus
alphabetFrequency(zikaVirus)

# Check alphabet of the zikaVirus using baseOnly = TRUE
alphabet(zikaVirus, baseOnly = TRUE)
```
Manipulating Biostrings
Using a short sequence (dna_seq) from the zikaVirus object, it is your turn to have a go with the two biological processes of transcription and translation.

In the first two parts of this exercise, you will apply these processes separately. In the last part, you'll apply them in one step.

You'll be using a very small sequence in this exercise, but remember that the power of Biostrings comes to light when manipulating much larger sequences.

The Biostrings package has already been loaded for you. Using zikaVirus, you will translate the first 21 characters into an AAString.

```{r}
# Unlist the set, select the first 21 letters, and assign to dna_seq
dna_seq <- subseq(unlist(zikaVirus), end = 21)
dna_seq

# Transcribe dna_seq into an RNAString object and print it
rna_seq <- RNAString(dna_seq) 
rna_seq

# Translate rna_seq into an AAString object and print it
aa_seq <- translate(rna_seq)
aa_seq

# ya da:
# Transcribe and translate dna_seq into an AAString object and print it
aa_seq<- translate(dna_seq)
aa_seq 




```

Cast characters as dates
As we saw in the video, you can use lubridate to parse and cast a date variable within a mutate(). In this exercise, you'll practice doing this with the baker_dates data, and then go even further to extract data from the dates like the labelled month. Remember to use ?month to read about the month() function and its arguments.

```{r}
# Add a line to extract labeled month
baker_dates_cast <- baker_dates %>% 
  mutate(last_date_appeared_us = dmy(last_date_appeared_us),
         last_month_us = month(last_date_appeared_us, label = TRUE))
         
# Make bar chart by last month
ggplot(baker_dates_cast, aes(x= last_month_us)) +geom_bar()

```










